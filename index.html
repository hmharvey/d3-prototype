<!DOCTYPE html>
<meta charset="utf-8">

<svg width="960" height="600"></svg>
<div id="chart"></div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var PERSPECT_LINK = 20;

// original data, this will be factored out
var nodes = [
  { id: "Diversity", module: 0, level: 1, radius: 36},
  { id: "diversity perspect 1"   , module: 0, level: 2, radius: 14 },
  { id: "diversity perspect 2"   , module: 0, level: 2, radius: 14 },
  // { id: "diversity source"   , module: 0, level: 3 },
  { id: "Workplace Ethics"   , module: 1, level: 1, radius: 24 },
  { id: "workplace perspect 1"   , module: 1, level: 2, radius: 14 },
  // { id: "workplace source 1"   , module: 0, level: 3 },
  // { id: "workplace source 2"   , module: 0, level: 3 },
  { id: "Tech", module: 2, level: 1, radius: 36 },
  { id: "tech perspect 1"   , module: 2, level: 2, radius: 14 },
  { id: "tech perspect 2"   , module: 2, level: 2, radius: 14 },
  { id: "Healthcare"  , module: 3, level: 1, radius: 48 },
  { id: "healthcare perspect 1"  , module: 3, level: 2, radius: 14 },
  { id: "healthcare perspect 2"  , module: 3, level: 2, radius: 14 },
  { id: "healthcare perspect 3"  , module: 3, level: 2, radius: 14 }
]

// lines connecting each topic with their perspective,
// will be factored out
var lines = [
	{ target: "Diversity", source: "diversity perspect 1" },
	{ target: "Diversity", source: "diversity perspect 2" },
  { target: "Workplace Ethics", source: "workplace perspect 1" },
  { target: "Tech", source: "tech perspect 1" },
  { target: "Tech", source: "tech perspect 2" },
  { target: "Healthcare", source: "healthcare perspect 1" },
  { target: "Healthcare" , source: "healthcare perspect 2" },
  { target: "Healthcare" , source: "healthcare perspect 3" }
]

// creating the container for the bubble graph
var width = 960
var height = 600
var container = d3.select('svg')
    .append("g")
    .attr("class", "nodes")

// creates the line elements to link the bubbles
var lineElements = container.append('g')
  .selectAll('line')
  .data(lines)
  .enter().append('line')
    .attr('stroke-width', 1)
    .attr('stroke', '#E5E5E5')

// creates the bubbles and sets their styles and functionality
var nodeElements = container.selectAll("circle")
  .data(nodes)
  .enter().append("circle")
  .attr('r', getRadius)
  .attr('fill', getNodeColor)
  .on('mouseover', mouseOver)
  .on('mousemove', mouseMove)
  .on('mouseout', mouseOut)

// creates the tooltip when a bubble is hovered
var tooltip = d3.select("#chart").append("div")
    .style("position", "absolute")
    .style("visibility", "hidden")
    .style("display", "block")
    .style("color", "white")
    .style("padding", "8px")
    .style("background-color", "#626D71")
    .style("border-radius", "6px")
    .style("text-align", "center")
    .style("font-family", "monospace")
    .style("width", "400px")
    .html("")

nodes.forEach(function(node) {
    node.x = width * 2
    node.y = height * 2
})

function mouseOver(node) {
    tooltip.text(node.id)
    node.isHovering = true
    simulation.alphaTarget(.3)
        .force('link', linkForce)
        .force('charge', charge)
        .force('collide', forceCollide)
        .restart()
        // .on('end', returnCharge)
    // wiggle.alphaTarget(.5)
    // simulation.alphaTarget(.5)
    //           .force('link', linkForce)
    //           .force('collide', forceCollide.strength(0.4))
    //           .restart()
    return tooltip.style("visibility", "visible")
}

function mouseMove() {
    return tooltip.style("top", (d3.event.pageY - 10) + "px")
                  .style("left", (d3.event.pageX + 10) + "px")
}

function mouseOut(node) {
    node.isHovering = false
    simulation.alphaTarget(0)
        .force('link', linkForce)
        .force('charge', charge)
        .force('collide', forceCollide)
        .restart()
    return tooltip.style("visibility", "hidden")
}

// creating a force between the links
var linkForce = d3.forceLink()
    .id(function (link) { return link.id })
    .distance(getDistance)
    .iterations(1)

function getDistance(link) {
  return link.source.radius + link.target.radius + PERSPECT_LINK
}

// returns the color of the node based on its level
function getNodeColor(node) {
    return node.level === 1 ? '#29f2ba' : '#5da5ef'
}

// returns the radius of the node based on the number
// of children it has
function getRadius(node) {
    if (node.level === 1) {
        return node.radius
    } else {
        return 14
    }
}

var modulePosition = {
  "3": {x: 0, y: 0},
  "2": {x: 0, y: 0},
  "1": {x: 0, y: 0},
  "0": {x: 0, y: 0}
}

//the hash, then set it to 250
var forceX = d3.forceX(function (d) {return modulePosition[d.module] ? modulePosition[d.module].x : 250})
    .strength(0.04)

//Same for forceY--these act as a gravity parameter so the different strength determines how closely
//the individual nodes are pulled to the center of their module position
var forceY = d3.forceY(function (d) {return modulePosition[d.module] ? modulePosition[d.module].y : 250})
    .strength(0.04)

var forceCollide = d3.forceCollide().radius(function(d) { return d.radius + 5 }).iterations(2)

var charge = d3.forceManyBody().strength(function(d) { return d.isHovering ? -600 : -20 })

var returnCharge = function() {
        simulation.alphaTarget(0.3)
        .force('link', linkForce)
        .force('charge', d3.forceManyBody().strength(function(d) { 20 }))
        .force('collide', forceCollide)
        .restart()
      }

// creates the forces between elements
var simulation = d3.forceSimulation(nodes)
    .alpha(1.5)
    .force('link', linkForce)
    .force('charge', charge)
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('forceX', forceX)
    .force('forceY', forceY)
    .force('collide', forceCollide)

simulation.nodes(nodes).on('tick', ticked)

function ticked() {
  d3.selectAll("circle")
      .attr('cx', function (node) { return node.x })
      .attr('cy', function (node) { return node.y })
  d3.selectAll("line")
      .attr('x1', function (link) { return link.source.x })
      .attr('y1', function (link) { return link.source.y })
      .attr('x2', function (link) { return link.target.x })
      .attr('y2', function (link) { return link.target.y })
}

simulation.force('link').links(lines)

</script>
